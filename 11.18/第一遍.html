<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>

    // //原型的继承
    // //构造函数首字母大写
    // function Persion() { }
    // console.dir(Persion); //构造函数
    // const persion = new Persion();  //实例
    // console.dir(persion); //实例对象
    // console.dir(persion instanceof Persion); //true
    // // 在原型上定义属性和方法，在实力上能够继承这些属性和方法
    // function Persion1() { }
    // Persion1.prototype.say = '七七'
    // const person = new Persion1()
    // console.log(person.say); //七七
    // console.log(person._proto_ === Persion1.prototype); //true

    // function Persion2() { }
    // Persion2.prototype.say = '七七'
    // const person2 = new Persion2()  //实例对象
    // console.log(person2.say); //七七
    // console.log(person2._proto_ === Persion2.prototype); //true
    // console.log(Persion2.prototype.constructor === Persion2); //true

    // const obj = {}
    // console.log(obj._proto_ === Object.prototype); //true
    // console.log(obj.toString()); //[object Object]
    // const obj2 = new Object()
    // console.log(obj2._proto_ === Object.prototype); //true
    // console.log(obj2.toString()); //[object Object]

    // // 封装promise\
    // // 1.引入fs模块
    // const fs = require('fs')
    // fs.readFile('./index.html', (err, data) => {
    //     if (err) {
    //         console.log(err)
    //     } else {
    //         console.log(data)
    //     }
    // })
    // // 3.使用promise封装
    // const P = new Promise(function (resolve, reject) {
    //     fs.readFile('./index.html', (err, data) => {
    //         if (err) {
    //             reject(err)
    //         } else {
    //             resolve(data)
    //         }
    //     })
    // })
    // P.then((res) => {
    //     console.log(res);
    // }).catch((err) => {
    //     console.log(err);
    // })

    // //实例化一个promise对象
    // const p = new Promise(function (resolve, reject) {
    //     resolve('成功')
    //     reject('失败')
    // })
    // p.then((res) => {
    //     console.log(res);
    // }).catch((err) => {
    //     console.log(err);
    // })
    // //简写方式
    // p.then((res) => {
    //     console.log(res);
    // }, (err) => {
    //     console.log(err);
    // })


    // // 1.实例化promise函数
    // const p = new Promise((resolve, reject) => {
    //     // 创建初始化链接对象
    //     const xhr = new XMLHttpRequest()
    //     // 确定请求方式和请求地址
    //     xhr.open('GET', '接口')
    //     // 发送请求
    //     xhr.send()
    //     // 绑定事件，处理响应结果
    //     xhr.onreadystatechange = () => {
    //         if (xhr.readyState === 4) {
    //             // 判断状态码
    //             if (xhr.status >= 200 && xhr.status < 300) {
    //                 resolve(xhr.response)
    //             } else {
    //                 reject(xhr.response)
    //             }
    //         }
    //     }
    // })
    // // 6.promise函数调用
    // p.then(res => {
    //     console.log(res);
    // }).catch(err => {
    //     console.log(err);
    // })
    //event loop 事件循环  先执行同步代码，再执行异步代码 在执行完同步代码后，会先执行微任务，再执行宏任务 微任务：promise  宏任务：settimeout
    // console.log(1);
    // setTimeout(() => {
    //     console.log(2);
    // }, 0);
    // new Promise((resolve, reject) => {
    //     console.log(3);
    //     resolve(4);
    // }).then((res) => {
    //     console.log(res);
    // })
</script>

</html>