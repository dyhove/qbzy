# Vue原理——MVVM MVC MVP

###### MVVM(Model-View-ViewModel)是一种软件架构设计模式，它是一种简化用户界面的事件驱动编程方式。

MVVM 分为 Model、View、ViewModel：
Model代表数据模型，数据和业务逻辑都在Model层中定义；
View代表UI视图，负责数据的展示；
ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；
Vue.js就是一个MVVM的实现者，它的核心就是实现了DOM监听与数据绑定。

###### MVVM源自于经典的MVC（Model-View-Controller）模式

View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。

###### MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。

在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题

## 初始Vue

#### Vue.js 是什么

Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。

#### mvvm的优缺点

优点：数据源和视图实现了双向绑定，很好的做到了数据的一致性相比于mvp各层的耦合度更低，一个viewmodel层可以给多个view层共用。

 缺点： 增加了大量的内存开销，增加了程序的编译时间，项目越大内存开销越大。数据绑定使得 Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题

#### Vue的模板语法

1.插值语法
功能：用于解析标签体内容

写法：{{xxx}},xxx是js表达式，且可以直接读取到data中的所有属性  

2.指令语法

功能:用于节气标签（包括：标签属性，标签体内容，绑定事件......）

Vue中有很多指令，且形式都是：v-???

#### Vue中数据绑定的方式

1.单向绑定（v-bind） ： 数据只能从data流向页面

2.双向绑定（v-model）：数据不仅能从data刘翔页面，还可以从页面流向data，双向绑定一般都应用在表单类元素上（如：input，select），v-model：value可以简写为v-model ,因为v-model默认收集的就是value的值

#### 双向绑定的原理

当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。
这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。
每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

#### el与data的两种写法

1.el有两种写法 

（1）new vue的时候配置el属性
（2）先创建Vue实例，随后通过vm.$mount("#")指定el的值

2.data有两种写法
（1）对象式
（2）函数式
备注：目前那种写法都可以，用到组件时，data必须是一个函数，否则会报错（如果data是一个函数的话，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据，如果写成对象形式，就相当于所有组件公用一个data，就会造成一个变，全都会变的后果）

3.原则：由Vue管理的函数，一定不能写箭头函数，一旦写了箭头函数，this就不再是Vue实例了

最后：.el在一进页面的时候就会挂载页面，并加载Dom，$mount挂载页面，可以控制挂载时间

#### 数据代理

1.Object.defineProperty

他的第一个参数是需要劫持的对象，第二个参数是劫持的属性名，第三个参数是各种配置项
配置项里面有三种方法，
enumerable（额扭（碗儿）buo）控制属性是否可以枚举，默认值是fals e{枚举：可循环的变量和属性}

writable（歪特buo）控制属性是否可以被修改，默认值是false

configurable（炕飞科儿buo）控制属性是否可以被删除，默认值是false

2.何为数据代理（概念）
概念：通过一个对象代理另一个对象中属性的操作，好处：更加方便操作data中的数据

3.Vue中的数据代理
通过Object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上面的属性，都指定一个getter/setter，在getter/setter内部去操作data中对应的属性

#### 事件处理

##### 1.事件的基本使用

（1）使用v-on:事件名或者@事件名绑定事件

（2）事件的回调需要配置在methods对象中，最终会在vm上

（3）methods中配置的函数，不需要用箭头函数！否则this就不是vm了

（4）methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或者组件的实例对象

（5）传参的话直接在后面写个括号，里面放置需要传递的参数

##### 2.事件修饰符

1.prevent ：阻止默认事件
2.stop：阻止事件冒泡
3.once：事件只触发一次

4.capture:使用事件的捕获模式

5.self：只有event.target是当前操作的元素时才能触发

6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕

##### 3.键盘事件

1.onkeydown：当某个键盘按键被按下时所触发的事件。
2.onkeyup：当某个被按下的键盘按键被松开时所触发的事件。
3.altKey属性是用来判断alt键是否被按下，
4.ctrlKey属性是用来判断ctrl键是否被按下，
5.shiftKey属性是用来判断shift键是否被按下

补充：console.log（e.key,e.keyCoede）第一个表示按的哪个键，第二个表示按键的数值

#### 计算属性（computed）

1.computed具有缓存性

2.computed是同步的，不能执行异步操作，数据和属性来源于data数据中，具有多对一的关系

定义：要用的属性不存在，要通过已有属性计算得来

原理：底层借助了Object.defineproperty方法提供的getter和setter

##### get函数什么时候执行？

1.初次读取时会执行一次

2.当依赖的数据发生改变时会被再次调用

优势：与methodes实现相比，内部有缓存机制，效率高，调试方便

#### 监视属性（watch）

定义：监听的属性必须要在data中存在或定义

原理：底层借助了Object.defineproperty方法提供的getter和setter

特点：当被监视的属性变化时，回调函数自动调用，进行相关操作

监视的属性必须存在，才能进行监视

watch是异步的

可以配置两个属性 ： immediate(一进页面立即监听)   deep(深度监听)

####  methods 方法表示一个具体的操作，主要书写业务逻辑；

#### computed,watch,methods的区别

computed具有缓存的特性，只有依赖值发生变化才会重新计算

computed都包含一个 getter 方法和一个 setter 方法

computed不支持异步

computed必须用return返回

watch 不具有缓存的特性，只要监听的值发生变化就会执行回调

watch 支持异步

watch 不是必须return

methods没有缓存性

#### 绑定样式

##### 1.class样式

写法：class="类名"  类名可以是字符串，对象，数组

字符串写法，适用于：样式的类名不确定，需要动态绑定

数组写法，适用于：需要绑定的样式个数不确定，名字也不确定

对象写法，适用于：样式的类名确定，不需要动态绑定

三元表达式写法，适用于：样式的类名确定，不需要动态绑定

##### 2.style样式

:style="{属性名：属性值}"

:style="[a,b]"其中 a,b是样式对象

#### vue中的key有什么作用?(key的内部原理)

##### 1、虚拟DOM中key的作用

key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM],

##### 2.对比规则

( 1).旧虚拟DOM中找到了与新虚拟DOM相同的key
①.若虚拟DOM中内容没变，直接使用之前的真实DOM!
②.若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOMN。

(2).旧虚拟DOM中未找到与新虚拟DOM相同的key

创建新的真实DOM，随后渲染到到页面。

##### 3.用index作为key可能会引发的问题:

1。若对数据进行:逆序添加、逆序删除等破坏顺序操作:
会产生没有必要的真实DOM更新=>界面效果没问题，但效率低。

2，如果结构中还包含输入类的DOM:
会产生错误DOM更新=>界面有问题

##### 4、开发中如何选择key? :

1.最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。

2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示,
使用index作为key是没有问题的。

#### 过滤器

vue 的过滤器分为两种,第⼀种是全局过滤器,通过 vue.filter 来进⾏定义,
第⼆种是局部过滤器,过滤器就是对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）

语法：1.注册过滤器 Vue.filter 或new Vue{filter}，2.使用过滤器，{{xxx | 过滤器名}} 或v-bind:属性 = “xxx” |  过滤器名

备注：1.过滤器也可以接收额外参数、多个过滤器也可以串联  2.并没有改变原本的数据，是产生新的对应的数据

#### 自定义指令

##### 定义语法

(1).局部指令:
new Vue({directives:{指令名:配置对象}）

(2).全局指令:
Vue.directive(指令名,配置对象) 或Vue.directive(指令名，回调函数

##### 配置对象中常用的3个回调

(1).bind: 指令与元素成功绑定时调用。
(2).inserted: 指令所在元素被插入页面时调用。
(3).update: 指令所在模板结构被重新解析时调用

备注：
1.指令定义时不加v-，但使用时要加v-;
2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。

3.过滤器可以接收额外参数，多个多滤器也可以串联
4.并没有改变原本的数据，是产生新的对应的数据

定义：要对显示的数据进行特定格式化后再显示

#### Vue监视数据的原理

1.vue会监视data中所有层次的数据

##### 2.如何监测对象中的数据？

通过setter实现监视，且要在new Vue时就传入要监测的数据
（1）对象中后追加的属性，vue默认不做响应式处理
（2）如需给后添加的属性做响应式，使用如果API
Vue.set（）或vm.$set

##### 3.如何监测数组中的数据？

通过包裹数组更新元素的方法实现，本质就是做了两件事：
（1）调用原生对应的方法对数组进行更新
（2）重新解析模板，进而更新页面
4.在Vue修改数组中的某个元素一定要用以下方法：
1.使用这些API:push(),pop(),shift(),unshift(),splice(),sort(),reverse(数组反转)
2.Vue.set()或vm.$set
注意：Vue.set()或vm.$set 不能给vm或vm的根 数据对象添加属性

#### Vue中使用组件的三大步骤

1.定义组件（创建组件）
2.注册组件
3.使用组件

##### 如何定义一个组件

使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但是也有区别
区别如下：

##### 1.el不要写，为什么？最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器

##### 2.data必须写成函数，为什么？避免组件重复使用，数据存在引入关系

备注：使用template可以配置组件结构

##### 2.如何注册组件？

1.局部注册：靠new Vue的时候传入components选项
2.全局注册：靠Vue.component（‘组件名’，‘组件’）
3.编写组件标签

##### < aaa ></ aaa>

#### 收集表单数据

若 <input type="text" /> ,则v-model收集的是value的值，用户输入的就是value的值

若 <input type="radio" />,则v-model收集的是value值，且要给标签配置value值 

若 <input type="checkbox" />
1.没有配置input的value属性，那么收集的就是checked
2.配置input的value属性
（1）v-model的初始值是非数组，那么收集的就是checked
（2）v-model的初始值是数组，那么收集的就是value组成的数组
备注：v-model的三个修饰符
lazy:失去焦点再收集数据
number：输入字符串转为有效的数字
trim：输入守卫空格过滤

#### Vue[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)函数有四个阶段：

**①实例创建之前/之后、②组件挂载之前/之后、③数据改变视图更新之前/之后、④实例销毁之前/之后**

beforeCreate(**实例创建之前**)：每个页面都是一个Vue实例,这时实例还没创建,所以data还不知道,也不能用watch监听。这个时候没有this

created(**实例创建之后**)：实例已经创建完，可以得到data,调用watch,但是页面还是空白的。有this

beforeMount(**组件挂载之前**)：页面[挂载](https://so.csdn.net/so/search?q=挂载&spm=1001.2101.3001.7020)前,这时节点还没渲染完成;

mounted(**组件挂载之后**)：页面挂载完成,页面的内容已经渲染出了,也可以访问到dom, 此时模板渲染完成;

beforeUpdate(**数据改变视图更新之前**):数据改变视图更新之前,就是虚拟DOM打补丁之前。这时访问到的DOM还有原有的DOM;

updated(**数据改变视图更新之后**):数据改变视图更新之后;

beforeDestroy(实例销毁之前):在destroy阶段,对data的改变不会再触发周期函数,说明此时Vue实例已经解除了事件监听以及和dom的绑定,但是dom结构依然存在。是最后一次可以使用data和methods的钩子函数。

 destroyed(实例销毁之后):实例已经被完全销毁


#### 明文密文

你的登录传给后端的是明文还是密文   1.我是直接明文传输
  2.我通过我们约定的加密方式来进行加密，我将密文传给后端，后端存储到数据库为密文，输入的是
明文----加密（密文） ----> 后端 ---->数据   3.我加密----->解密 ----> 后端明文