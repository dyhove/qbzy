<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

<script>
    // let 总结
    // 1. let声明的变量只在let命令所在的代码块内有效
    // 2. let不允许在相同作用域内，重复声明同一个变量
    // 3. let声明的变量不存在变量提升
    // 4.可以声明多个变量
    // let a
    // let b, c, d
    // let e = 10
    // let f = 20, g = 30, h = []

    // // 块级作用域
    // {
    //     let name = '77'
    // }
    // let name = '66'
    // console.log(name); //66
    // // 不存在变量提升
    // console.log(song);
    // let song = 'song'

    // const 总结
    // 1. const声明的常量只在const命令所在的代码块内有效
    // 2. const不允许在相同作用域内，重复声明同一个变量
    // 3. const声明的常量不存在变量提升
    // 4. const声明的常量必须赋值
    // 5. co const 定义的基本数据类型不能修改 定义的复杂数据类型能修改
    // 6.约定使用const声明常量必须要大写
    // const PI = '七七'

    // 解构赋值总结
    // 1. 数组的解构赋值 数组的解构赋值是按照位置来的，
    // const F4 = ['aa', 'bb', 'cc','dd']
    // let [a,b,c,d] = F4
    // let f = F4[0]
    // console.log(f);
    // 2. 对象的解构赋值 对象的解构赋值是按照属性名来的
    // const Z = {
    //     name:'七七',
    //     age:11,
    //     job:function(){
    //         console.log('我是七七');
    //     }
    // }
    // let {name} = Z
    // console.log(name);
    // 对于数组和对象的元素修改，不算是对原数组和对象的修改，而是对原数组和对象的解构赋值的修改
    //     。因为只是修改了内容，并没有修改指针的指向，所以原数组和对象的内容并没有改变。



    // 模板字符串
    // 1. 可以换行
    // let restlta = '<ul>' + '<li>aa</li>' + '<li>bb</li>' + '<li>cc</li>' + '</ul>'
    // let restltb = `<ul>
    //     <li>aa</li>
    //     <li>bb</li>
    //     <li>cc</li>
    // </ul>`
    // document.write(restltb)
    // document.write(restlta)


    //对象的简写
    //当对象的属性名和属性值一样时，可以简写 简写的时候属性名是变量名
    // let name = '七七'
    // let age = 11
    // let job = function(){
    //     console.log('我是七七');
    // }
    // let obj = {
    //     name,
    //     age,
    //     job
    // }
    // console.log(obj);


    // 箭头函数
    // 1. 箭头函数没有this，箭头函数的this是在定义时绑定的，而不是在调用时绑定的
    // 2. 箭头函数没有arguments，箭头函数的arguments是在定义时绑定的，而不是在调用时绑定的
    // 3. 箭头函数不能用作构造函数
    // window.name = 'window'
    // const Z = {
    //     name: "七七"
    // }
    // function name2() {
    //     console.log(this.name);
    // }
    // let name1 = () => {
    //     console.log(this.name);
    // }

    // name2()
    // name1()

    // name2.call(Z)
    // name1.call(Z)

    // 箭头函数的简写
    // let fun = (a, b) => a + b
    // 当代码块中只有一条语句时，可以省略大括号和return
    // let fn = (a) => a + 1
    // 当代码块中只有一个参数时，可以省略小括号
</script>

</html>