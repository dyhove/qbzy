<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 1. 链式调用
    // const fs = require('fs');
    // const leaves = () => {
    //     return new Promise((resolve, reject) => {
    //         fs.readFile('./article/万叶.md', (err, data) => {
    //             if (err) {
    //                 reject(err);
    //             } else {
    //                 resolve(data);
    //             }
    //         });
    //     });
    // };
    // const mulan = () => {
    //     return new Promise((resolve, reject) => {
    //         fs.readFile('./article/木兰.md', (err, data) => {
    //             if (err) {
    //                 reject(err);
    //             } else {
    //                 resolve(data);
    //             }
    //         });
    //     });
    // }
    // const chushi = () => {
    //     return new Promise((resolve, reject) => {
    //         fs.readFile('./article/出师表.md', (err, data) => {
    //             if (err) {
    //                 reject(err);
    //             } else {
    //                 resolve(data);
    //             }
    //         });
    //     });
    // }

    // 3. catch方法
    // leaves().catch((err) => {
    // console.log(err);
    // }).then(() => {
    // chushi().catch((err) => {
    // console.log(err);
    // })
    // }).then(() => {
    // mulan().catch((err) => {
    // console.log(err);
    // })
    // })

    // leaves().then((res) => {
    //     return res.toString()


    // }).then((data) => {
    //     console.log(data);
    //     let resulet = mulan().then((res) => {
    //         console.log(res.toString());
    //         return res.toString()
    //     });
    //     console.log(resulet);
    //     return resulet + data;
    // }).then((data1) => {
    //     console.log(data1);
    //     chushi().then((res) => {
    //         console.log(res.toString());
    //     })
    // })
    // 2. 封装公共promise函数
    // const p1 = new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //         resolve(11111);
    //     }, 2000);
    // });
    // const p2 = new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //         reject(22222);
    //     }, 1000);
    // });
    // const p3 = new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //         resolve(33333);
    //     }, 3000);
    // });
    // 4. all和race方法
    // Promise.race([p1, p2, p3]).then((res) => {
    //     console.log("res:", res);
    // }).catch((err) => {
    //     console.log("err:", err);
    // });

    // 5. finall方法
    // function p() {
    //     return new Promise((resolve, reject) => {
    //         setTimeout(() => {
    //             resolve('我是');
    //             reject('我是');
    //         });
    //     });
    // }
    // p().then((res) => {
    //     console.log(res);
    // }).catch((err) => {
    //     console.log(err);
    // }).finally(() => {
    //     console.log('我是finally');
    // });


    // 6.async和await
    // function timout() {
    //     return 'hello world';
    // }
    // async function test() {
    //     const res = await timout();
    //     console.log(res);
    // }
    // test();
    // async function fn1(){
    //     return 10;
    // }
    // async function fn2(num){
    //     return num + 11;
    // }
    // async function fn3(num){
    //     return num + 12;
    // }
    // async function fn4(num){
    //     return num + 13;
    // }
    // async function fn5(num){
    //     return num + 14;
    // }
    // async function fn6(){
    //     try{
    //         let res = await fn1();
    //         res = await fn2(res);
    //         res = await fn3(res);
    //         res = await fn4(res);
    //         res = await fn5(res);
    //         console.log(res); // 60
    //     } catch(err){
    //         console.log(err);
    //     }
    // }
    // fn6();

    // const wz = `这是一段文字1`
    // const wz1 = `这是一段文字2`
    // const wz2= `这是一段文字3`
    // function fn1(){
    //     return new Promise((resolve,reject)=>{
    //         setTimeout(()=>{
    //             resolve(wz)
    //         },1000)
    //     })
    // }
    // async function fn2(){
    //     const res = await fn1();
    //     console.log(res); // 这是一段文字1
    // }
    // fn2();

    // 7.map
    // const map = new Map([
    //     ['name','张三'],
    //     ['title','标题']
    // ])
    // console.log(map.size);
    // map.has('name') //true
    // map.get('name') //张三
    // map.has('title') //true
    // map.get('title') //标题
    // map.set('age',18)

    // const map = new Map()
    // map.set('name', '张三')
    // map.set('change', function () {
    //     console.log('我是change方法');
    // })
    // let key = {
    //     school: 'Schuool'
    // }
    // map.set(key, ['北', '清'])
    // console.log(map);
    // map.delete('name')
    // console.log(map);
    // console.log(map.has('name'));
    // map.clear()
    // console.log(map);
    // for (let [key] of map) {
    //     console.log(key);
    // }


    // 8.set
    // let set = new Set()
    // console.log(set);
    // set.add('万叶')
    // set.add('万叶1')
    // set.add('万叶2')
    // set.add('万叶3')
    // set.add('万叶4')
    // console.log(set);
    // console.log(set.size);
    // set.delete('万叶')
    // console.log(set);
    // console.log(set.has('万叶'));
    // for (let item of set) {
    //     console.log(item);
    // }
    // set.clear()
    // console.log(set);
    // let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    // let set1 = new Set(arr)
    // console.log(set1);
    // let arr1 = [...set1]
    // console.log(arr1);
    // let arr2 = Array.from(set1)
    // console.log(arr2);
</script>

</html>