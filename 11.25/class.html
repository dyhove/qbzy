<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    // 01 class类的写法
    // 1.概念
    // ES6提供了更接近传统语言的写法，引入了class（类）这个概念，作为对象的模板。
    // 2.作用
    // 通过class关键字，可以定义类。
    // 3.优点
    // 新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法，但是`class`的继承实现的还是原型链，完全背离了面向对象编程的语法，这是它的缺点。
    // 04.class的get和set方法 get和set方法用于拦截某个属性的存取行为。
    // 05class的static方法
    // 概念：1.类（class）通过static关键字定义静态方法。
    //特点: 静态方法不会被实例继承，而是直接通过类来调用，这就大大提高了方法的可读性。
    // 06.class类的继承
    // 关键字 extends
    // 关键方法 super super()  super.属性  父类.call(this)

    // 传统ES5的写法
    // function Point(x,y) {
    //     this.x = x
    //     this.y = y
    // }
    // Point.prototype.toSring = function() {
    //     return '('+this.x+','+this.y+')'
    // }
    // let p = new Point(1,2)
    // let resule = p.toSring()
    // console.log(resule);

    // ES6的写法
    // class Point {
    //     constructor(x,y) {
    //         this.x = x
    //         this.y = y
    //     }
    //     toSring(){
    //         return '('+this.x+','+this.y+')'
    //     }
    // }
    // let p = new Point(1,2)
    // let resule = p.toSring()
    // console.log(resule);

    // 02 类声明的例子
    // function Phone(brand,price) {
    //     this.brand = brand
    //     this.price = price
    // }
    // //添加方法
    // Phone.prototype.call = function() {
    //     console.log('这可以电话');
    // }
    // //实例化对象
    // let vivo = new Phone('IQOO',3000)
    // console.log(vivo);
    // //class
    // class shouji {
    //     constructor(brand,price) {
    //         this.brand = brand
    //         this.price = price
    //     }
    //     call() {
    //         console.log('这可以电话');
    //     }
    // }
    // let vivo1 = new shouji('IQOO',3000)
    // console.log(vivo1);

    //03 class的get和set方法
    // get和set方法用于拦截某个属性的存取行为。
    // class Phone{
    //     get price() {
    //         console.log('get读取这个内容了');
    //         return '666'
    //     }
    //     set price(value) {
    //         console.log('set设置这个内容了');
    //     }
    // }
    // // 实例化对象
    // let s = new Phone()
    // // 读取属性
    // console.log(s.price);
    // // 设置属性
    // s.price = 1000

    // 04 class的static方法
    //extends : 继承
    //     class Tle {
    //         static tle(n = 1) {
    //             return n * 3
    //         }
    //     }
    //     class Big extends Tle {
    //         static tel(n) {
    //             return super.tle(n) * super.tle(n)
    //         }
    //     }
    //这是调用自身的方法
    //     console.log(Big.tel()); // 9
    //     console.log(Big.tel(2)); // 36
    // // 实例化
    //     let tp = new Tle()
    //     console.log(Big.tle(3)); // 9 （不会受父类实例化的影响）
    //     console.log(tp.tle()); // 'TypeError: tp.tle is not a function' tp.tle不是一个函数

    // 05 class类的继承
    // //手机
    // function Phone(brand, price) {
    //     this.brand = brand
    //     this.price = price
    // }
    // Phone.prototype.call = function () {
    //     console.log('这可以电话');
    // }
    // //智能手机
    // function SmPone(brand, price, color, size) {
    //     Phone.call(this, brand, price)
    //     this.color = color
    //     this.size = size
    // }
    // //设置子级构造函数的原型对象
    // SmPone.prototype = new Phone
    // SmPone.prototype.constructor = SmPone
    // //声明子类的方法
    // SmPone.prototype.photo = function () {
    //     console.log('这可以拍照');
    // }
    // SmPone.prototype.Game = function () {
    //     console.log('这可以玩游戏');
    // }
    // const xxx = new SmPone('星星', '9999', '黑色', '5.5inch')
    // console.log(xxx);
        // 例子2
    // class Phone {
    //     //构造方法
    //     constructor(brand, price) {
    //         this.brand = brand
    //         this.price = price
    //     }
    //     //父类的成员属性（声明方法）
    //     call() {
    //         console.log('这可以电话');
    //     }
    // }
    // //子类继承父类
    // class SmPone extends Phone {
    //     //构造方法
    //     constructor(brand, price, color, size) {
    //         //调用父类的构造方法
    //         super(brand, price)  //承接父类的属性 
    //         this.color = color
    //         this.size = size
    //     }
    //     //子类的成员属性（声明方法）
    //     photo() {
    //         console.log('这可以拍照');
    //     }
    //     Game() {
    //         console.log('这可以玩游戏');
    //     }
    //     call() {
    //         console.log('这个还能打视频');
    //     }
    // }
    // const vivo = new SmPone('IQOO', '5999', '白色', '5.5inch')
    // console.log(vivo);
    // vivo.photo()
    // vivo.Game()
    // vivo.call()
</script>

</html>