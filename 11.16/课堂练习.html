<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    //event loop 事件循环  先执行同步代码，再执行异步代码 在执行完同步代码后，会先执行微任务，再执行宏任务 微任务：promise  宏任务：settimeout
    // console.log(1);
    // setTimeout(() => {
    //     console.log(2);
    // }, 0);
    // new Promise((resolve, reject) => {
    //     console.log(3);
    //     resolve(4);
    // }).then((res) => {
    //     console.log(res);
    // })
    // console.log(5);
    // 实现继承的方法
    // 1.原型链继承
    // function Super() {
    //     this.a = 1
    // }
    // Super.prototype.say = function() {
    //     console.log('say');
    // }
    // function Sub() {}
    // Sub.prototype = new Super()
    // const test = new Sub()
    // console.log(test.say()); //say
    // // 2.构造函数继承
    // function Super() {
    //     this.a = 1
    // }
    // function Sub() { }
    // Sub.prototype = new Super()
    // const test = new Sub()
    // console.log(test.a); //1
    // test.a.push(3)
    // console.log(test.a); //[1,3]
    // const test2 = new Sub()
    // console.log(test2.a); //[1,3]
    // let Super = function () {
    //     this.a = 1
    // }

    // let Sub = function () {
    //     Super.call(this)
    //     this.b = 2
    // }
    // Sub.prototype.say = function () {
    //     console.log('say');
    // }
    // Super.prototype.say = 3
    // const test = new Sub()
    // console.log(test, 'test');

        // function Super(){this.a = [1,2]}
        // Super.prototype.say = function(){console.log('say');}
        // function Sub(){
        //     Super.call(this)
        //     this.b = 2
        // }
        // Sub.prototype = new Super()
        // const test = new Sub()
        // console.log(test.a); //[1,2]
        // test.a.push(3)
        // console.log(test.a); //[1,2,3]
        // const test2 = new Sub()
        // console.log(test2.a); //[1,2]
        // 寄生组合继承 
            // function Super() {
            //     this.a = 1
            // }
            // Super.prototype.say = function () {
            //     console.log('say');
            // }
            // function Sub() {
            //     Super.call(this)
            //     this.b = 2
            // }
            // Sub.prototype = Object.create(Super.prototype)
            // Sub.prototype.constructor = Sub
            // const test = new Sub()
            // console.log(test); //Sub {a: 1, b: 2}
            // 递归实现深拷贝
            // function deepClone(obj) {
            //     if (typeof obj !== 'object' || obj == null) {
            //         return obj
            //     }
            //     let result
            //     if (obj instanceof Array) {
            //         result = []
            //     } else {
            //         result = {}
            //     }
            //     for (let key in obj) {
            //         if (obj.hasOwnProperty(key)) {
            //             result[key] = deepClone(obj[key])
            //         }
            //     }
            //     return result
            // }
            
</script>

</html>