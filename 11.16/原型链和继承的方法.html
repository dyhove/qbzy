<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //原型和原型链 通过原型链实现继承
        //原型链的继承 优点：通过原型继承多个引用类型的属性和方法
        // 缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题
        // function Super() { this.a = 1 }
        // Super.prototype.say = function () { console.log('say') }
        // function Sub() { }
        // Sub.prototype = new Super()

        // const test = new Sub()
        // console.log(test.say())// say
        // 2、盗用构造函数 优点：每个实例都会有自己的a属性，哪怕是引用值也不会被污染
        // 缺点：Super构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub的实例无法访问Super原型上的方法
        // let Super = function () { this.a = 1 }
        // let Sub = function () {
        //     Super.call(this)
        //     this.b = 2
        // }
        // const test = new Sub()
        // console.log(test.a)//1
        // 3、组合继承集合了【原型继承】和【盗用构造函数继承】的优点
        // 缺点：存在效率问题，Super始终会被调用两次
        // function Super() { this.a = [1, 2] }
        // Super.prototype.say = function () { console.log(hhh) }
        // function Sub() {
        //     Super.call(this)
        //     this.b = 2
        // }
        // Sub.prototype = new Super()
        // 4、原型式继承 优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
        // 缺点：无法判断实例的构造函数是父类还是子类
        // const obj = { a: 1 }

        // const test = Object.create(obj)
        // 5、寄生式继承优点：根据一个对象克隆创建另一个对象，并增强对象

        // 缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

        // 注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制
        // function createObj(o) {
        //     let clone = objectCopy(o)
        //     clone.say = function () {
        //         console.log('hhh')
        //     }
        //     return clone
        // }

        // const obj = { a: 1 }
        // const test = createObj(obj)
        // 6、寄生式组合继承
        // function Super() { this.a = [1, 2] }
        // Super.prototype.say = function () { console.log('hhh') }
        // function Sub() {
        //     Super.call(this)
        //     this.b = 2
        // }

        // Sub.prototype = Object.create(Super.prototype)
        // Sub.prototype.constructor = Sub

        // const test = new Sub()




        // 原型 **原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**
        // function Person() {
        //
        // }
        // 原型链 **当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**
        // const obj = {}
        // console.log(obj.__proto__ === Object.prototype) // true
        // console.log(obj.toString)  // ƒ toString() { [native code] }，toString是继承Object.prototype上的方法

        // const obj2 = new Object()
        // console.log(obj2.__proto__ === Object.prototype) // true
        // console.log(obj2.toString) // ƒ toString() { [native code] }

        //event loop 事件循环  先执行同步代码，再执行异步代码 在执行完同步代码后，会先执行微任务，再执行宏任务 微任务：promise  宏任务：settimeout
        // console.log(1);
        // setTimeout(() => {
        //     console.log(2);
        // }, 0);
        // new Promise((resolve, reject) => {
        //     console.log(3);
        //     resolve(4);
        // }).then((res) => {
        //     console.log(res);
        // })
        // console.log(5);

// 什么是原型？

// **原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。**

// 什么是prototype?

//    **显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。**

// 什么是 __ proto __ ?

// **可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.**

// 什么是构造函数？

// **构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用**

// 什么是原型链？

// **当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，就到`原型的原型`上查找，若还是查找不到就指向`null`。**
    </script>
</body>

</html>